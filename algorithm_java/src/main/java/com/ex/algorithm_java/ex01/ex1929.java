package com.ex.algorithm_java.ex01;

import java.util.Scanner;
// 에라토스테네스의 체로 푼다.
// 에라토스테네스의 체 방식은 2부터 소수의 제곱과 그 이후 배수들을 제외해 나가는 방식이다.
//1~10을 보자. 1은 소수가 아니니 제외. 2~10이다.
//
//2는 소수이다, 그럼 2의 제곱부터 배수들을 지운다. 4, 6, 8, 10이다.
////다음 수 3은 소수이다. 그럼 3의 제곱부터 배수들을 지운다. 9.
////여기까지만 하는데 내가 구할 수는 10까지 이고, 제곱해서 10이 넘지 않는 수까지만 해주면 된다.
////10은 3의 제곱보다 크고, 5의 제곱보다 작다. 그러니 3까지만 해준다.
//
//그럼 제외한 수는 4, 6, 8, 9, 10이다. 그럼 나머지는 소수이니 소수는 2, 3, 5, 7이 되는 것이다. 이것이 에라토스테네스의 체 방법이다.
////하나만 더 예를 들면 25이다. 소수 5의 제곱과 같으니 소수 5까지만 진행한다.
////2의 배수, 3의 배수, 5의 배수를 제외한다. 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24 / 9, 12, 15, 18, 21, 24 / 25 수들을
// 제외한 나머지가 소수인 것이다.
// 그럼 소수는 2, 3, 5, 7, 11, 13, 17, 19, 23이 되는 것이다. (소수를 구하는게 가능한지 문의하는 것이 핵심)
public class ex1929 {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int a = sc.nextInt();
        int b = sc.nextInt();

        // 에라토스테네스의 체
        //소수 판별 배열 b까지 나타내기위해 범위는 b+1로
        //소수 판별은 꼭 boolean 형을 사용하지 않고 int형이나 String형 같이 다른 자료형을 사용해도 된다.
        boolean[] arr = new boolean[b + 1];
        StringBuilder sb = new StringBuilder();
        //0과 1은 소수가 아니다.
        arr[0] = true;
        arr[1] = true;
        //문제에서 말한 제곱해서 b을 넘지 않을때까지만 소수의 배수를 제외해 주면 된다.
        for(int i = 2; i * i <= b; i++) {
            //소수일때
            if(!arr[i]) { // 기본은 false로 되있으므로
                //j에는 소수의 배수들이 들어와야하기때문에 아래 조건이 들어간다.
                for(int j = i * i; j <= b; j += i) {
                    //소수의 배수들에는 true를 저장
                    arr[j] = true;
                }
            }
        }
        // 배열에서 false 되어있는게 소수
        for(int i = a; i <= b; i++) {
            if(!arr[i]) sb.append(i).append("\n"); // 소수 =( arr[i] = false) 인것
        }
        System.out.println(sb);
        sc.close();
    }

}
